[
  {
    name: 'newObj1',
    type: { tag: 'class', name: 'str' },
    value: { tag: 'none' }
  },
  {
    name: 'newObj2',
    type: { tag: 'class', name: 'str' },
    value: { tag: 'none' }
  },
  {
    a: [ [Object], [Object] ],
    name: 's',
    type: { tag: 'class', name: 'str' },
    value: { tag: 'none' }
  },
  {
    a: [ [Object], [Object] ],
    name: 'j',
    type: { tag: 'class', name: 'str' },
    value: { tag: 'none' }
  }
] [ 'newObj1', 'newObj2', 's', 'j' ]
(module
    (import "js" "memory" (memory 1))
    (func $assert_not_none (import "imports" "assert_not_none") (param i32) (result i32))
    (func $assert_in_range (import "imports" "assert_in_range") (param i32) (param i32) (result i32))
    (func $print_num (import "imports" "print_num") (param i32) (result i32))
    (func $print_bool (import "imports" "print_bool") (param i32) (result i32))
    (func $print_none (import "imports" "print_none") (param i32) (result i32))
    (func $print_str (import "imports" "print_str") (param i32) (result i32))
    (func $abs (import "imports" "abs") (param i32) (result i32))
    (func $min (import "imports" "min") (param i32) (param i32) (result i32))
    (func $max (import "imports" "max") (param i32) (param i32) (result i32))
    (func $pow (import "imports" "pow") (param i32) (param i32) (result i32))
    (func $alloc (import "libmemory" "alloc") (param i32) (result i32))
    (func $load (import "libmemory" "load") (param i32) (param i32) (result i32))
    (func $store (import "libmemory" "store") (param i32) (param i32) (param i32))
    
    (global $newObj1 (export "newObj1") (mut i32) (i32.const 0))
(global $newObj2 (export "newObj2") (mut i32) (i32.const 0))
(global $s (export "s") (mut i32) (i32.const 0))
(global $j (export "j") (mut i32) (i32.const 0))
    
    (func $str$access (param $self i32) (param $index i32) (result i32)
  (local $newstr i32)
  (local $buffer i32)
  ;; check if index is out of range
  (local.get $self)
  (i32.const 0) ;;0
  (call $load)
  (local.get $index)
  (call $assert_in_range)
  (local.set $newstr) ;; just scraping up the return
  ;; alloc space for new string and set 1 as length
  (i32.const 2)
  (call $alloc)
  (local.set $newstr)
  (local.get $newstr)
  (i32.const 0) ;;as
  (i32.const 1)
  (call $store)
  ;; get char from self and set it as the string for new string
  (local.get $self)
  (i32.add (i32.const 1) (local.get $index))
  (call $load)
  (local.set $buffer)
  (local.get $newstr)
  (i32.const 1)
  (local.get $buffer)
  (call $store)
  (local.get $newstr)
  (return))
(func $str$length (param $self i32) (result i32)
    (local.get $self)
    (call $assert_not_none)
    (i32.const 0)
    (call $load) ;; load the length of the string
    (return))
(func $str$lessthan (param $self i32) (param $rhs i32) (result i32)
    (local $selfLength i32)
    (local $i i32)
    (local.get $self)
    (i32.load)
    (local.set $selfLength)
    (i32.const 1)
    (local.set $i)
    (block 
        (loop 
            (br_if 1 (i32.le_s (local.get $i) (local.get $selfLength) )(i32.eqz) )
            (i32.load (i32.add (local.get $self) (local.get $i)))
            (i32.load (i32.add (local.get $rhs) (local.get $i)))
            (i32.gt_s)  ;;return false if l >= r
            (if (then (i32.const 0) (return)))
            (i32.add (local.get $i) (i32.const 1))(local.set $i)
            (br 0)
        )
    ) ;;end block and loop otherwise return 1
    (i32.const 1)
    (return))
(func $str$greaterthan (param $self i32) (param $rhs i32) (result i32)
    (local $selfLength i32)
    (local $rhsLength i32)
    (local $i i32)
    (local.get $self)
    (i32.load)
    (local.set $selfLength)
    
    (i32.const 1)
    (local.set $i)
    (block 
        (loop 
            (br_if 1 (i32.le_s (local.get $i) (local.get $selfLength) )(i32.eqz) )
            (i32.load (i32.add (local.get $self) (local.get $i)))
            (i32.load (i32.add (local.get $rhs) (local.get $i)))
            (i32.lt_s)  ;;return false if l < r
            (if (then (i32.const 0) (return)))
            (i32.add (local.get $i) (i32.const 1))(local.set $i)
            (br 0)
        )
    ) ;;end block and loop otherwise return 1
    (i32.const 1)
    (return))
(func $str$equalsto (param $self i32) (param $rhs i32) (result i32)
    (local $selfLength i32)
    (local $rhsLength i32)
    (local $i i32)
    (local.get $self)
    (i32.load)
    (local.set $selfLength)
    (local.get $rhs)
    (i32.load)
    (local.set $rhsLength)
    (i32.ne (local.get $selfLength) (local.get $rhsLength))
    (if
      (then
        i32.const 0
        return ;; if length is not equal, return false
      )
    )
    (i32.const 1)
    (local.set $i)
    (block 
        (loop 
            (br_if 1 (i32.le_s (local.get $i) (local.get $selfLength) )(i32.eqz) )
            (i32.load (i32.add (local.get $self) (local.get $i)))
            (i32.load (i32.add (local.get $rhs) (local.get $i)))
            (i32.ne)  ;;check if left and right character values are not equal
            (if (then (i32.const 0) (return)))
            (i32.add (local.get $i) (i32.const 1))(local.set $i)
            (br 0)
        )
    ) ;;end block and loop
    (i32.const 1)
    (return))

(func $str$concat (param $self i32) (param $rhs i32) (result i32)
(i32.const 0)
(return))
(func $str$copyconstructor (param $self i32) (param $rhs i32) (result i32)
(i32.const 0)
(return))
    (func (export "exported_func") (result i32)
      (local $$last i32)
(local $$selector i32)
(i32.const 0)
(global.set $newObj1)
(i32.const 0)
(global.set $newObj2)
(i32.const 0)
(global.set $s)
(i32.const 0)
(global.set $j)
(local.set $$selector (i32.const 0))
(loop $loop
(block $startProg1
              (local.get $$selector)
(br_table $startProg1)    
            ) ;; end $startProg1
            (i32.const 2)
call $alloc
(global.set $newObj1)
(global.get $newObj1)
(i32.const 0)
(i32.const 3)
call $store
(global.get $newObj1)
(i32.const 1)
(i32.const 6513249)
call $store
(global.get $newObj1)
(global.set $s)
(i32.const 2)
call $alloc
(global.set $newObj2)
(global.get $newObj2)
(i32.const 0)
(i32.const 3)
call $store
(global.get $newObj2)
(i32.const 1)
(i32.const 6974058)
call $store
(global.get $newObj2)
(global.set $j)
(global.get $s)
(i32.const 0)
(call $str$access)
(global.set $j)
(global.get $j)
(call $print_str)
(local.set $$last)
            ) ;; end $loop
      (local.get $$last)
    )
  )
{
  instance: Instance [WebAssembly.Instance] {},
  module: Module [WebAssembly.Module] {}
}
Consider key  newObj1
Consider key  newObj2
Consider key  s
Consider key  j
Consider key  exported_func
hello
{ tag: 'object', name: 'str', address: 20 }
