[
  {
    name: 'newObj1',
    type: { tag: 'class', name: 'str' },
    value: { tag: 'none' }
  },
  {
    name: 'newObj2',
    type: { tag: 'class', name: 'str' },
    value: { tag: 'none' }
  },
  {
    a: [ [Object], [Object] ],
    name: 'valname1',
    type: { tag: 'class', name: 'str' },
    value: { tag: 'none' }
  },
  {
    a: [ [Object], [Object] ],
    name: 'valname2',
    type: { tag: 'number' },
    value: { tag: 'none' }
  },
  {
    a: [ [Object], [Object] ],
    name: 's1',
    type: { tag: 'class', name: 'str' },
    value: { tag: 'none' }
  },
  {
    a: [ [Object], [Object] ],
    name: 's2',
    type: { tag: 'class', name: 'str' },
    value: { tag: 'none' }
  }
] [ 'newObj1', 'newObj2', 'valname1', 'valname2', 's1', 's2' ]
(module
    (import "js" "memory" (memory 1))
    (func $assert_not_none (import "imports" "assert_not_none") (param i32) (result i32))
    (func $assert_in_range (import "imports" "assert_in_range") (param i32) (param i32) (result i32))
    (func $print_num (import "imports" "print_num") (param i32) (result i32))
    (func $print_bool (import "imports" "print_bool") (param i32) (result i32))
    (func $print_none (import "imports" "print_none") (param i32) (result i32))
    (func $print_str (import "imports" "print_str") (param i32) (result i32))
    (func $abs (import "imports" "abs") (param i32) (result i32))
    (func $min (import "imports" "min") (param i32) (param i32) (result i32))
    (func $max (import "imports" "max") (param i32) (param i32) (result i32))
    (func $pow (import "imports" "pow") (param i32) (param i32) (result i32))
    (func $alloc (import "libmemory" "alloc") (param i32) (result i32))
    (func $load (import "libmemory" "load") (param i32) (param i32) (result i32))
    (func $store (import "libmemory" "store") (param i32) (param i32) (param i32))
    
    (global $newObj1 (export "newObj1") (mut i32) (i32.const 0))
(global $newObj2 (export "newObj2") (mut i32) (i32.const 0))
(global $valname1 (export "valname1") (mut i32) (i32.const 0))
(global $valname2 (export "valname2") (mut i32) (i32.const 0))
(global $s1 (export "s1") (mut i32) (i32.const 0))
(global $s2 (export "s2") (mut i32) (i32.const 0))
    
    (func $str$access (param $self i32) (param $index i32) (result i32)
  (local $newstr i32)
  (local $buffer i32)
  ;; check if index is out of range
  (local.get $self)
  (i32.const 0) ;;0
  (call $load)
  (local.get $index)
  (call $assert_in_range)
  (local.set $newstr) ;; just scraping up the return
  ;; alloc space for new string and set 1 as length
  (i32.const 2)
  (call $alloc)
  (local.set $newstr)
  (local.get $newstr)
  (i32.const 0) ;;as
  (i32.const 1)
  (call $store)
  ;; get char from self and set it as the string for new string
  (local.get $self)
  (i32.add (i32.const 1) (local.get $index))
  (call $load)
  (local.set $buffer)
  (local.get $newstr)
  (i32.const 1)
  (local.get $buffer)
  (call $store)
  (local.get $newstr)
  (return))
(func $str$length (param $self i32) (result i32)
    (local.get $self)
    (call $assert_not_none)
    (i32.const 0)
    (call $load) ;; load the length of the string
    (return))
(func $str$lessthan (param $self i32) (param $rhs i32) (result i32)
    (local $selfLength i32)
    (local $i i32)
    (local.get $self)
    (i32.load)
    (local.set $selfLength)
    (i32.const 1)
    (local.set $i)
    (block 
        (loop 
            (br_if 1 (i32.le_s (local.get $i) (local.get $selfLength) )(i32.eqz) )
            (i32.load (i32.add (local.get $self) (local.get $i)))
            (i32.load (i32.add (local.get $rhs) (local.get $i)))
            (i32.gt_s)  ;;return false if l >= r
            (if (then (i32.const 0) (return)))
            (i32.add (local.get $i) (i32.const 1))(local.set $i)
            (br 0)
        )
    ) ;;end block and loop otherwise return 1
    (i32.const 1)
    (return))
(func $str$greaterthan (param $self i32) (param $rhs i32) (result i32)
    (local $selfLength i32)
    (local $rhsLength i32)
    (local $i i32)
    (local.get $self)
    (i32.load)
    (local.set $selfLength)
    
    (i32.const 1)
    (local.set $i)
    (block 
        (loop 
            (br_if 1 (i32.le_s (local.get $i) (local.get $selfLength) )(i32.eqz) )
            (i32.load (i32.add (local.get $self) (local.get $i)))
            (i32.load (i32.add (local.get $rhs) (local.get $i)))
            (i32.lt_s)  ;;return false if l < r
            (if (then (i32.const 0) (return)))
            (i32.add (local.get $i) (i32.const 1))(local.set $i)
            (br 0)
        )
    ) ;;end block and loop otherwise return 1
    (i32.const 1)
    (return))
(func $str$equalsto (param $self i32) (param $rhs i32) (result i32)
    (local $selfLength i32)
    (local $rhsLength i32)
    (local $i i32)
    (local.get $self)
    (i32.load)
    (local.set $selfLength)
    (local.get $rhs)
    (i32.load)
    (local.set $rhsLength)
    (i32.ne (local.get $selfLength) (local.get $rhsLength))
    (if
      (then
        i32.const 0
        return ;; if length is not equal, return false
      )
    )
    (i32.const 1)
    (local.set $i)
    (block 
        (loop 
            (br_if 1 (i32.le_s (local.get $i) (local.get $selfLength) )(i32.eqz) )
            (i32.load (i32.add (local.get $self) (local.get $i)))
            (i32.load (i32.add (local.get $rhs) (local.get $i)))
            (i32.ne)  ;;check if left and right character values are not equal
            (if (then (i32.const 0) (return)))
            (i32.add (local.get $i) (i32.const 1))(local.set $i)
            (br 0)
        )
    ) ;;end block and loop
    (i32.const 1)
    (return))

(func $str$concat (param $self i32) (param $rhs i32) (result i32)
  (local $newlen i32)
  (local $len1 i32)
  (local $len2 i32)
  (local $newstr i32)
  (local $i i32)
  (local $j i32)
  (local $char i32)
  (local.get $rhs)
  (call $assert_not_none)
  (local.get $self)
  (i32.const 0)
  (call $load)
  (local.set $len1)
  (local.get $rhs)
  (i32.const 0)
  (call $load)
  (local.set $len2)
  (i32.add (local.get $len1) (local.get $len2))
  (local.set $newlen)
  (local.get $newlen)
  (i32.const 4)
  (i32.div_s)
  (i32.const 1)
  (i32.add)
  (call $alloc)
  (local.set $newstr)
  ;; set length of new string
  (local.get $newstr)
  (i32.const 0)
  (local.get $newlen)
  (call $store)
  ;; concat from string 1
  (local.set $i (i32.const 0))
  (local.set $j (i32.const 0))
  (loop $loop1
    local.get $self
    (i32.add (i32.const 1) (local.get $i))
    (call $load)
    (local.set $char)
    (local.get $newstr)
    (i32.add (i32.const 1) (local.get $i))
    (local.get $char)
    (call $store)
    (local.set $i (i32.add (i32.const 1) (local.get $i)))
    (local.set $j (i32.add (i32.const 4) (local.get $j)))
    (i32.lt_s (local.get $j) (local.get $len1))
    br_if $loop1
  )

  ;; concat from string 2
  (local.set $i (i32.const 0))
  (local.set $j (i32.const 0))
  (loop $loop2
    local.get $rhs
    (i32.add (i32.const 1) (local.get $i))
    (call $load)
    (local.set $char)
    (i32.add (local.get $len1) (local.get $newstr))
    (i32.add (i32.const 1)(local.get $i))
    (local.get $char)
    (call $store)
    (local.set $i (i32.add (i32.const 1) (local.get $i)))
    (local.set $j (i32.add (i32.const 4) (local.get $j)))
    (i32.lt_s (local.get $j) (local.get $len2))
    br_if $loop2
  )

  (local.get $newstr)
  (return))
(func $str$copyconstructor (param $self i32) (param $rhs i32) (result i32)
(i32.const 0)
(return))
    (func (export "exported_func") (result i32)
      (local $$last i32)
(local $$selector i32)
(i32.const 0)
(global.set $newObj1)
(i32.const 0)
(global.set $newObj2)
(i32.const 0)
(global.set $valname1)
(i32.const 0)
(global.set $valname2)
(i32.const 0)
(global.set $s1)
(i32.const 0)
(global.set $s2)
(local.set $$selector (i32.const 0))
(loop $loop
(block $startProg1
              (local.get $$selector)
(br_table $startProg1)    
            ) ;; end $startProg1
            (i32.const 2)
call $alloc
(global.set $newObj1)
(global.get $newObj1)
(i32.const 0)
(i32.const 3)
call $store
(global.get $newObj1)
(i32.const 1)
(i32.const 6513249)
call $store
(global.get $newObj1)
(global.set $s1)
(i32.const 2)
call $alloc
(global.set $newObj2)
(global.get $newObj2)
(i32.const 0)
(i32.const 3)
call $store
(global.get $newObj2)
(i32.const 1)
(i32.const 6710628)
call $store
(global.get $newObj2)
(global.set $s2)
(global.get $s1)
(call $assert_not_none)
(local.set $$last)
(global.get $s1)
(global.get $s2)
(call $str$concat)
(global.set $valname1)
(global.get $valname1)
(call $assert_not_none)
(local.set $$last)
(global.get $valname1)
(call $str$length)
(global.set $valname2)
(global.get $valname2)
(call $print_num)
(local.set $$last)
            ) ;; end $loop
      (local.get $$last)
    )
  )
{
  "a": {
    "line": 1
  },
  "funs": [],
  "inits": [
    {
      "a": {
        "line": 2
      },
      "name": "s",
      "type": {
        "tag": "class",
        "name": "str"
      },
      "value": {
        "tag": "none"
      }
    }
  ],
  "classes": [],
  "stmts": [
    {
      "a": {
        "line": 2
      },
      "tag": "assign",
      "name": "s",
      "value": {
        "a": {
          "line": 2
        },
        "tag": "call",
        "name": "str",
        "arguments": [
          {
            "tag": "literal",
            "value": {
              "tag": "str",
              "value": "abc"
            }
          }
        ]
      }
    },
    {
      "tag": "index-assign",
      "obj": {
        "a": {
          "line": 3
        },
        "tag": "id",
        "name": "s"
      },
      "index": {
        "a": {
          "line": 3
        },
        "tag": "literal",
        "value": {
          "tag": "num",
          "value": 0
        }
      },
      "value": {
        "tag": "call",
        "name": "str",
        "arguments": [
          {
            "tag": "literal",
            "value": {
              "tag": "str",
              "value": "v"
            }
          }
        ]
      }
    }
  ]
}
Consider key  newObj1
Consider key  newObj2
Consider key  valname1
Consider key  valname2
Consider key  s1
Consider key  s2
Consider key  exported_func
hello
{ tag: 'num', value: 6 }
