[
  {
    name: 'newObj1',
    type: { tag: 'class', name: 'C' },
    value: { tag: 'none' }
  },
  {
    a: [ [Object], [Object] ],
    name: 'valname1',
    type: { tag: 'class', name: 'str' },
    value: { tag: 'none' }
  },
  {
    a: [ [Object], [Object] ],
    name: 'c',
    type: { tag: 'class', name: 'C' },
    value: { tag: 'none' }
  }
] [ 'newObj1', 'valname1', 'c' ]
{
  globals: [ 'newObj1', 'valname1', 'c' ],
  functions: '(func $str$access (param $self i32) (param $index i32) (result i32)\r\n' +
    '  (local $newstr i32)\r\n' +
    '  (local $buffer i32)\r\n' +
    '  ;; check if index is out of range\r\n' +
    '  (local.get $self)\r\n' +
    '  (i32.const 0) ;;0\r\n' +
    '  (call $load)\r\n' +
    '  (local.get $index)\r\n' +
    '  (call $assert_in_range)\r\n' +
    '  (local.set $newstr) ;; just scraping up the return\r\n' +
    '  ;; alloc space for new string and set 1 as length\r\n' +
    '  (i32.const 2)\r\n' +
    '  (call $alloc)\r\n' +
    '  (local.set $newstr)\r\n' +
    '  (local.get $newstr)\r\n' +
    '  (i32.const 0) ;;as\r\n' +
    '  (i32.const 1)\r\n' +
    '  (call $store)\r\n' +
    '  ;; get char from self and set it as the string for new string\r\n' +
    '  (i32.add (local.get $index) (local.get $self))\r\n' +
    '  (i32.const 1)\r\n' +
    '  (call $load)\r\n' +
    '  (local.set $buffer)\r\n' +
    '  (local.get $newstr)\r\n' +
    '  (i32.const 1)\r\n' +
    '  (local.get $buffer)\r\n' +
    '  (call $store)\r\n' +
    '  (local.get $newstr)\r\n' +
    '  (return))\r\n' +
    '(func $str$length (param $self i32) (result i32)\r\n' +
    '    (local.get $self)\r\n' +
    '    (call $assert_not_none)\r\n' +
    '    (i32.const 0)\r\n' +
    '    (call $load) ;; load the length of the string\r\n' +
    '    (return))\r\n' +
    '(func $str$lessthan (param $self i32) (param $rhs i32) (result i32)\r\n' +
    '    (local $selfLength i32)\r\n' +
    '    (local $i i32)\r\n' +
    '    (local.get $self)\r\n' +
    '    (i32.load)\r\n' +
    '    (local.set $selfLength)\r\n' +
    '    (i32.const 1)\r\n' +
    '    (local.set $i)\r\n' +
    '    (block \r\n' +
    '        (loop \r\n' +
    '            (br_if 1 (i32.le_s (local.get $i) (local.get $selfLength) )(i32.eqz) )\r\n' +
    '            (i32.load (i32.add (local.get $self) (local.get $i)))\r\n' +
    '            (i32.load (i32.add (local.get $rhs) (local.get $i)))\r\n' +
    '            (i32.gt_s)  ;;return false if l >= r\r\n' +
    '            (if (then (i32.const 0) (return)))\r\n' +
    '            (i32.add (local.get $i) (i32.const 1))(local.set $i)\r\n' +
    '            (br 0)\r\n' +
    '        )\r\n' +
    '    ) ;;end block and loop otherwise return 1\r\n' +
    '    (i32.const 1)\r\n' +
    '    (return))\r\n' +
    '(func $str$greaterthan (param $self i32) (param $rhs i32) (result i32)\r\n' +
    '    (local $selfLength i32)\r\n' +
    '    (local $rhsLength i32)\r\n' +
    '    (local $i i32)\r\n' +
    '    (local.get $self)\r\n' +
    '    (i32.load)\r\n' +
    '    (local.set $selfLength)\r\n' +
    '    \r\n' +
    '    (i32.const 1)\r\n' +
    '    (local.set $i)\r\n' +
    '    (block \r\n' +
    '        (loop \r\n' +
    '            (br_if 1 (i32.le_s (local.get $i) (local.get $selfLength) )(i32.eqz) )\r\n' +
    '            (i32.load (i32.add (local.get $self) (local.get $i)))\r\n' +
    '            (i32.load (i32.add (local.get $rhs) (local.get $i)))\r\n' +
    '            (i32.lt_s)  ;;return false if l < r\r\n' +
    '            (if (then (i32.const 0) (return)))\r\n' +
    '            (i32.add (local.get $i) (i32.const 1))(local.set $i)\r\n' +
    '            (br 0)\r\n' +
    '        )\r\n' +
    '    ) ;;end block and loop otherwise return 1\r\n' +
    '    (i32.const 1)\r\n' +
    '    (return))\r\n' +
    '(func $str$equalsto (param $self i32) (param $rhs i32) (result i32)\r\n' +
    '    (local $selfLength i32)\r\n' +
    '    (local $rhsLength i32)\r\n' +
    '    (local $i i32)\r\n' +
    '    (local.get $self)\r\n' +
    '    (i32.load)\r\n' +
    '    (local.set $selfLength)\r\n' +
    '    (local.get $rhs)\r\n' +
    '    (i32.load)\r\n' +
    '    (local.set $rhsLength)\r\n' +
    '    (i32.ne (local.get $selfLength) (local.get $rhsLength))\r\n' +
    '    (if\r\n' +
    '      (then\r\n' +
    '        i32.const 0\r\n' +
    '        return ;; if length is not equal, return false\r\n' +
    '      )\r\n' +
    '    )\r\n' +
    '    (i32.const 1)\r\n' +
    '    (local.set $i)\r\n' +
    '    (block \r\n' +
    '        (loop \r\n' +
    '            (br_if 1 (i32.le_s (local.get $i) (local.get $selfLength) )(i32.eqz) )\r\n' +
    '            (i32.load (i32.add (local.get $self) (local.get $i)))\r\n' +
    '            (i32.load (i32.add (local.get $rhs) (local.get $i)))\r\n' +
    '            (i32.ne)  ;;check if left and right character values are not equal\r\n' +
    '            (if (then (i32.const 0) (return)))\r\n' +
    '            (i32.add (local.get $i) (i32.const 1))(local.set $i)\r\n' +
    '            (br 0)\r\n' +
    '        )\r\n' +
    '    ) ;;end block and loop\r\n' +
    '    (i32.const 1)\r\n' +
    '    (return))\r\n' +
    '\r\n' +
    '(func $str$concat (param $self i32) (param $rhs i32) (result i32)\r\n' +
    '  (local $newlen i32)\r\n' +
    '  (local $len1 i32)\r\n' +
    '  (local $len2 i32)\r\n' +
    '  (local $newstr i32)\r\n' +
    '  (local $i i32)\r\n' +
    '  (local $j i32)\r\n' +
    '  (local $char i32)\r\n' +
    '  (local.get $rhs)\r\n' +
    '  (call $assert_not_none)\r\n' +
    '  (local.get $self)\r\n' +
    '  (i32.const 0)\r\n' +
    '  (call $load)\r\n' +
    '  (local.set $len1)\r\n' +
    '  (local.get $rhs)\r\n' +
    '  (i32.const 0)\r\n' +
    '  (call $load)\r\n' +
    '  (local.set $len2)\r\n' +
    '  (i32.add (local.get $len1) (local.get $len2))\r\n' +
    '  (local.set $newlen)\r\n' +
    '  (local.get $newlen)\r\n' +
    '  (i32.const 4)\r\n' +
    '  (i32.div_s)\r\n' +
    '  (i32.const 1)\r\n' +
    '  (i32.add)\r\n' +
    '  (call $alloc)\r\n' +
    '  (local.set $newstr)\r\n' +
    '  ;; set length of new string\r\n' +
    '  (local.get $newstr)\r\n' +
    '  (i32.const 0)\r\n' +
    '  (local.get $newlen)\r\n' +
    '  (call $store)\r\n' +
    '  ;; concat from string 1\r\n' +
    '  (local.set $i (i32.const 0))\r\n' +
    '  (local.set $j (i32.const 0))\r\n' +
    '  (loop $loop1\r\n' +
    '    local.get $self\r\n' +
    '    (i32.add (i32.const 1) (local.get $i))\r\n' +
    '    (call $load)\r\n' +
    '    (local.set $char)\r\n' +
    '    (local.get $newstr)\r\n' +
    '    (i32.add (i32.const 1) (local.get $i))\r\n' +
    '    (local.get $char)\r\n' +
    '    (call $store)\r\n' +
    '    (local.set $i (i32.add (i32.const 1) (local.get $i)))\r\n' +
    '    (local.set $j (i32.add (i32.const 4) (local.get $j)))\r\n' +
    '    (i32.lt_s (local.get $j) (local.get $len1))\r\n' +
    '    br_if $loop1\r\n' +
    '  )\r\n' +
    '\r\n' +
    '  ;; concat from string 2\r\n' +
    '  (local.set $i (i32.const 0))\r\n' +
    '  (local.set $j (i32.const 0))\r\n' +
    '  (loop $loop2\r\n' +
    '    local.get $rhs\r\n' +
    '    (i32.add (i32.const 1) (local.get $i))\r\n' +
    '    (call $load)\r\n' +
    '    (local.set $char)\r\n' +
    '    (i32.add (local.get $len1) (local.get $newstr))\r\n' +
    '    (i32.add (i32.const 1)(local.get $i))\r\n' +
    '    (local.get $char)\r\n' +
    '    (call $store)\r\n' +
    '    (local.set $i (i32.add (i32.const 1) (local.get $i)))\r\n' +
    '    (local.set $j (i32.add (i32.const 4) (local.get $j)))\r\n' +
    '    (i32.lt_s (local.get $j) (local.get $len2))\r\n' +
    '    br_if $loop2\r\n' +
    '  )\r\n' +
    '\r\n' +
    '  (local.get $newstr)\r\n' +
    '  (return))\r\n' +
    '(func $str$copyconstructor (param $self i32) (param $rhs i32) (result i32)\r\n' +
    '(i32.const 0)\r\n' +
    '(return))(func $C$gets (param $self i32) (param $i i32) (result i32)\n' +
    '    (local $valname3 i32)\n' +
    '(local $$last i32)\n' +
    '(local $$selector i32)\n' +
    '    (i32.const 0)\n' +
    '(local.set $valname3)\n' +
    '    (local.set $$selector (i32.const 0))\n' +
    '(loop $loop\n' +
    '(block $startFun1\n' +
    '              (local.get $$selector)\n' +
    '(br_table $startFun1)    \n' +
    '            ) ;; end $startFun1\n' +
    '            (global.get $valname2)\n' +
    '(local.get $i)\n' +
    '(call $str$access)\n' +
    '(local.set $valname3)\n' +
    '(local.get $valname3)\n' +
    'return\n' +
    '            ) ;; end $loop\n' +
    '    (i32.const 0)\n' +
    '    (return))\n' +
    '\n' +
    '(func $C$__init__ (param $self i32) (result i32)\n' +
    '    (local $newObj2 i32)\n' +
    '(local $$last i32)\n' +
    '(local $$selector i32)\n' +
    '    (i32.const 0)\n' +
    '(local.set $newObj2)\n' +
    '    (local.set $$selector (i32.const 0))\n' +
    '(loop $loop\n' +
    '(block $startFun2\n' +
    '              (local.get $$selector)\n' +
    '(br_table $startFun2)    \n' +
    '            ) ;; end $startFun2\n' +
    '            (i32.const 2)\n' +
    'call $alloc\n' +
    '(local.set $newObj2)\n' +
    '(local.get $newObj2)\n' +
    '(i32.const 0)\n' +
    '(i32.const 3)\n' +
    'call $store\n' +
    '(local.get $newObj2)\n' +
    '(i32.const 1)\n' +
    '(i32.const 6583137)\n' +
    'call $store\n' +
    '(local.get $self)\n' +
    '(i32.const 0)\n' +
    '(local.get $newObj2)\n' +
    'call $store\n' +
    '            ) ;; end $loop\n' +
    '    (i32.const 0)\n' +
    '    (return))',
  mainSource: '(local $$last i32)\n' +
    '(local $$selector i32)\n' +
    '(i32.const 0)\n' +
    '(global.set $newObj1)\n' +
    '(i32.const 0)\n' +
    '(global.set $valname1)\n' +
    '(i32.const 0)\n' +
    '(global.set $c)\n' +
    '(local.set $$selector (i32.const 0))\n' +
    '(loop $loop\n' +
    '(block $startProg1\n' +
    '              (local.get $$selector)\n' +
    '(br_table $startProg1)    \n' +
    '            ) ;; end $startProg1\n' +
    '            (i32.const 1)\n' +
    'call $alloc\n' +
    '(global.set $newObj1)\n' +
    '(global.get $newObj1)\n' +
    '(i32.const 0)\n' +
    '(i32.const 0)\n' +
    'call $store\n' +
    '(global.get $newObj1)\n' +
    '(call $C$__init__)\n' +
    '(local.set $$last)\n' +
    '(global.get $newObj1)\n' +
    '(global.set $c)\n' +
    '(global.get $c)\n' +
    '(call $assert_not_none)\n' +
    '(local.set $$last)\n' +
    '(global.get $c)\n' +
    '(i32.const 1)\n' +
    '(call $C$gets)\n' +
    '(global.set $valname1)\n' +
    '(global.get $valname1)\n' +
    '(call $print_str)\n' +
    '(local.set $$last)\n' +
    '            ) ;; end $loop',
  newEnv: {
    globals: Map(1) { 'c' => true },
    classes: Map(1) { 'C' => [Map] },
    locals: Set(0) {},
    labels: [ '$startProg1' ],
    offset: 1
  }
}
